data6$Comment..TCGA.Barcode. <- strtrim(data6$Comment..TCGA.Barcode., 16)
data6 <- subset(data6, duplicated(Comment..TCGA.Barcode.) == FALSE)
data6 <- subset (data6, Comment..TCGA.Barcode. %in% data1$Comment..TCGA.Barcode.)
barcodePairing[i,6] <- length(data6$Comment..TCGA.Barcode.)
}
if (exists("data7", mode = "list")){
data7$Comment..TCGA.Barcode. <- strtrim(data7$Comment..TCGA.Barcode., 16)
data7 <- subset(data7, duplicated(Comment..TCGA.Barcode.) == FALSE)
data7 <- subset (data7, Comment..TCGA.Barcode. %in% data1$Comment..TCGA.Barcode.)
barcodePairing[i,7] <- length(data7$Comment..TCGA.Barcode.)
}
}
}
write.table(barcodePairing, paste0(writePath, "/", "barcodePairing.txt"),
append = FALSE, sep = "\t", quote = FALSE)
}
#' Print code for PostgreSQL for probeinfo tables
#'
#' Print the code to create the probeinfo table in the PostgreSQL database
#' (needs the dataframe file from function download).
#' It also outputs the code in writePath/*createTable.txt.
#'
#' @include init
#' @usage printPostgreSQLCodeprobeinfo(cancer, array)
printPostgreSQLCodeprobeinfo <- function (cancer, array){
init(cancer, array)
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "_probeinfo(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
classes <- sapply(probeinfo, class)
for (i in 1:length(colnames(probeinfo))){
n <- max(apply(probeinfo[,i, drop = FALSE], 1, nchar))
new <- paste0(colnames(probeinfo)[i]," VARCHAR(", n, "),")
code <- paste0(code, new)
}
code <- paste0(code, paste0("CONSTRAINT pk_", cancerName, "_", arrayName, "_",
colnames(probeinfo)[1], "PRIMARY KEY (", colnames(probeinfo)[1],"), "))
write(code, paste0(writePath, "/", cancerName, "_", arrayName, "_probeinfo_createTable.txt"))
return (code)
}
#' Print code for PostgreSQL
#'
#' Print the code to create the table in the PostgreSQL database
#' (needs the sampleinfo file from filterBarcodes).
#' It also outputs the code in writePath/*createTable.txt.
#'
#' @include init
#' @usage printPostgreSQLCode(cancer, array)
printPostgreSQLCode <- function (cancer, array){
init(cancer, array)
samples <- read.table(paste0(readPath, "/", cancerName, "_sampleinfo_", arrayName, "_to_SQL.txt"),
sep = "\t", header = TRUE)
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
varchar <- max(apply(probeinfo[,1, drop = FALSE], 1, nchar))
probe <- paste0(colnames(probeinfo)[1], " VARCHAR(", varchar, "),")
code <- paste0(code, probe)
for (i in 1:length(colnames(samples))){
expression <- paste0(colnames(samples)[i], " FLOAT(4), ", collapse = NULL)
code <- paste0(code, expression)
}
code <- paste0(code, paste0("CONSTRAINT pk_", cancerName, "_", arrayName, "_",
colnames(probeinfo)[1],"PRIMARY KEY (", colnames(probeinfo)[1],"), "))
code <- paste0(code, paste0("FOREIGN KEY (", colnames(probeinfo)[1], ") REFERENCES ",
cancerName, ".", arrayName, "_probeinfo(", colnames(probeinfo)[1], "));"))
write(code, paste0(writePath, "/", cancerName, "_", arrayName, "_createTable.txt"))
return (code)
}
#' Do PostgreSQL table correlations
#'
#' Do correlations of tables stored in PostgreSQL and store significant correlations
#' in another PostrgreSQL table.
#'
#' @include init
#' @usage corFromTableToTable(drv, ..., from.query = NULL, and.query = NULL,
#' to.table = NULL, stdev.threshold.from = 0, stdev.threshold.and = 0, pval.threshold = 1, nthreads = 1)
#' @details Requires parallel package.
#'  drv
#'    A character string specifying the database management system driver.
#'  ...
#'    Arguments needed to connect to the database, such as user, password, dbname, host, port, etc.
#'  from.query
#'    PostgreSQL statement to select or filter the data in a specified PostgreSQL table
#'    for correlations.
#'  and.query
#'    PostgreSQL statement to select or filter the data in a second specified PostgreSQL table
#'    for correlations.
#'  to.table
#'    PostgreSQL table where the significant correlations will be written.
#'  stdev.threshold.from
#'    Filters out all rows containing values with lower standard deviation than the specified threshold
#'    (in from.query).
#'  stdev.threshold.and
#'    Filters out all rows containing values with lower standard deviation than the specified threshold
#'    (in and.query).
#'  pval.threshold
#'    Correlations with a p-value higher than this threshold will be considered significant and registered
#'    in to.table.
#'  nthreads
#'    Number of threads this functions will use.
corFromTableToTable <- function (drv, ..., from.query = NULL, and.query = NULL,
to.table = NULL, stdev.threshold.from = 0,
stdev.threshold.and = 0, pval.threshold = 1, nthreads = 1){
require(parallel)
if (exists("dbConnect") == FALSE){
require(RPostgreSQL)
}
con <- dbConnect(drv, ...)
if (is.null(con)) {
stop("supply a connection")
}
if (is.null(from.query)) {
stop("supply a table to read from")
}
if (is.null(to.table)) {
stop("supply a table to write to")
}
if (!(is.numeric(stdev.threshold.from))){
stop("'stdev.threshold.from' must be numeric")
}
if (!(is.numeric(stdev.threshold.and))){
stop("'stdev.threshold.and' must be numeric")
}
if (!(is.numeric(pval.threshold))){
stop("'pval.threshold' must be numeric")
}
# Prepare and filter dataframes
filter <- function (dataframe, stdev){
system('echo Filtering started $(date)')
startrow <- nrow(dataframe)
df <- na.exclude(dataframe)
noNArow <- nrow(df)
df$sd <- apply(df[,-1], 1, sd, na.rm=TRUE)
df <- subset(df, sd > stdev)
df <- df[,-length(df)]
endrow <- nrow(df)
diffrow <- startrow - endrow
noNA <- startrow - noNArow
cat(paste('\n', diffrow, 'probes filtered out.', noNA, 'probes contained NAs\n'))
system('echo Filtering ended $(date)')
return (df)
}
# Do all probe correlations
correlation <- function (x, y, to.table, pval.threshold){
a <- as.numeric(x[-1])
b <- as.numeric(y[-1])
corr <- cor.test (a, b, method = "spearman")
count <<- count + 1
if (corr$p.value <= pval.threshold) {
x_probe_name <- x[1]
y_probe_name <- y[1]
if (!init){
system('echo Initializing connection with PostgreSQL $(date)')
con1 <<- dbConnect(drv, ...)
dbSendQuery(con1, "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;")
dbSendQuery(con1, 'BEGIN;')
init <<- TRUE
}
# because the pvalue is defined as float(4) in postgres
if  (corr$p.value < 5.60519e-45) corr$p.value <- 0
statement <- paste0("INSERT INTO ", to.table, " VALUES ('",
x_probe_name, "', '", y_probe_name, "', ",
corr$estimate, ",", corr$p.value, ");")
dbSendQuery(con1, statement)
}
if (count >= 100000){
system('echo 100000 counts done $(date)')
dbSendQuery(con1, 'COMMIT;')
dbSendQuery(con1, 'BEGIN;')
count <<- 0
}
}
apply2 <- function (X, Y, DOMAIN, CTION, ...) {
CTION <- match.fun(CTION)
dl <- length(dim(Y))
if (!dl)
stop("dim(Y) must have a positive length")
if (is.object(Y))
Y <- if (dl == 2L)
as.matrix(Y)
else as.array(Y)
d <- dim(Y)
dn <- dimnames(Y)
ds <- seq_len(dl)
if (is.character(DOMAIN)) {
if (is.null(dnn <- names(dn)))
stop("'Y' must have named dimnames")
DOMAIN <- match(DOMAIN, dnn)
if (any(is.na(DOMAIN)))
stop("not all elements of 'DOMAIN' are names of dimensions")
}
s.call <- ds[-DOMAIN]
s.ans <- ds[DOMAIN]
d.call <- d[-DOMAIN]
d.ans <- d[DOMAIN]
dn.call <- dn[-DOMAIN]
dn.ans <- dn[DOMAIN]
d2 <- prod(d.ans)
if (d2 == 0L) {
newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call),
1L))
ans <- CTION(if (length(d.call) < 2L)
newY[, 1]
else array(X,newY[, 1L], d.call, dn.call), ...)
return(if (is.null(ans)) ans else if (length(d.ans) <
2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))
}
newY <- aperm(Y, c(s.call, s.ans))
dim(newY) <- c(prod(d.call), d2)
ans <- vector("list", d2)
if (length(d.call) < 2L) {
if (length(dn.call))
dimnames(newY) <- c(dn.call, list(NULL))
for (i in 1L:d2) {
tmp <- CTION(X,newY[, i], ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
}
else for (i in 1L:d2) {
tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
ans.list <- is.recursive(ans[[1L]])
l.ans <- length(ans[[1L]])
ans.names <- names(ans[[1L]])
if (!ans.list)
ans.list <- any(unlist(lapply(ans, length)) != l.ans)
if (!ans.list && length(ans.names)) {
all.same <- vapply(ans, function(Y) identical(names(Y),
ans.names), NA)
if (!all(all.same))
ans.names <- NULL
}
len.a <- if (ans.list)
d2
else length(ans <- unlist(ans, recursive = FALSE))
if (length(DOMAIN) == 1L && len.a == d2) {
names(ans) <- if (length(dn.ans[[1L]]))
dn.ans[[1L]]
return(ans)
}
if (len.a == d2)
return(array(ans, d.ans, dn.ans))
if (len.a && len.a%%d2 == 0L) {
if (is.null(dn.ans))
dn.ans <- vector(mode = "list", length(d.ans))
dn.ans <- c(list(ans.names), dn.ans)
return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans,
is.null, NA))) dn.ans))
}
return(ans)
}
apply2half <- function (X, Y, DOMAIN, CTION, ...) {
rowmatch <- match(X[1], Y[,1])
if (rowmatch < nrow (Y)){
Y <- Y[((1L+rowmatch):nrow(Y)),]
CTION <- match.fun(CTION)
dl <- length(dim(Y))
if (!dl)
stop("dim(Y) must have a positive length")
if (is.object(Y))
Y <- if (dl == 2L)
as.matrix(Y)
else as.array(Y)
d <- dim(Y)
dn <- dimnames(Y)
ds <- seq_len(dl)
if (is.character(DOMAIN)) {
if (is.null(dnn <- names(dn)))
stop("'Y' must have named dimnames")
DOMAIN <- match(DOMAIN, dnn)
if (any(is.na(DOMAIN)))
stop("not all elements of 'DOMAIN' are names of dimensions")
}
s.call <- ds[-DOMAIN]
s.ans <- ds[DOMAIN]
d.call <- d[-DOMAIN]
d.ans <- d[DOMAIN]
dn.call <- dn[-DOMAIN]
dn.ans <- dn[DOMAIN]
d2 <- prod(d.ans)
if (d2 == 0L) {
newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call),
1L))
ans <- CTION(if (length(d.call) < 2L)
newY[, 1]
else array(X,newY[, 1L], d.call, dn.call), ...)
return(if (is.null(ans)) ans else if (length(d.ans) <
2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))
}
newY <- aperm(Y, c(s.call, s.ans))
dim(newY) <- c(prod(d.call), d2)
ans <- vector("list", d2)
if (length(d.call) < 2L) {
if (length(dn.call))
dimnames(newY) <- c(dn.call, list(NULL))
for (i in 1L:d2) {
tmp <- CTION(X,newY[, i], ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
}
else for (i in 1L:d2) {
tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
ans.list <- is.recursive(ans[[1L]])
l.ans <- length(ans[[1L]])
ans.names <- names(ans[[1L]])
if (!ans.list)
ans.list <- any(unlist(lapply(ans, length)) != l.ans)
if (!ans.list && length(ans.names)) {
all.same <- vapply(ans, function(Y) identical(names(Y),
ans.names), NA)
if (!all(all.same))
ans.names <- NULL
}
len.a <- if (ans.list)
d2
else length(ans <- unlist(ans, recursive = FALSE))
if (length(DOMAIN) == 1L && len.a == d2) {
names(ans) <- if (length(dn.ans[[1L]]))
dn.ans[[1L]]
return(ans)
}
if (len.a == d2)
return(array(ans, d.ans, dn.ans))
if (len.a && len.a%%d2 == 0L) {
if (is.null(dn.ans))
dn.ans <- vector(mode = "list", length(d.ans))
dn.ans <- c(list(ans.names), dn.ans)
return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans,
is.null, NA))) dn.ans))
}
return(ans)
}
}
# Get dataframes from the database
cat('\nGetting data from database ')
system('date')
# this fetches the sample names
# x_rs <- dbGetQuery(con,
#                    "SELECT 'SELECT ' || array_to_string(ARRAY(SELECT c.column_name
#                     FROM information_schema.columns As c
#                     WHERE c.table_name = 'humanmethylation450'
#                       AND c.table_schema = 'coad'
#                       AND  c.column_name ~ '^TCGA_'
#                     ), ',') || ' FROM humanmethylation450 WHERE chromosome = 22' AS sqlstmt; ")
x_rs <-  dbGetQuery(con, from.query)
if (!is.null(and.table)) {
y_rs <- dbGetQuery(con, and.query)
}
system('echo Finished getting data from database $(date)')
x_rs <- filter(x_rs, stdev.threshold.from)
if (!is.null(and.table)) {
y_rs <- filter(y_rs, stdev.threshold.and)
}
system('echo Making clusters $(date)')
cluster <- makeCluster(nthreads)
clusterExport(cluster, "connect")
clusterEvalQ(cluster, library(RPostgreSQL))
clusterEvalQ(cluster, init <- FALSE)
clusterEvalQ(cluster, count <- 0)
system('echo Starting parallel apply $(date)')
if (!is.null(and.table)) {
parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2, Y = y_rs, DOMAIN = 1,
CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)
clusterEvalQ(cluster, dbSendQuery(con1, "COMMIT;"))
stopCluster(cl = cluster)
} else {
parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2half, Y = x_rs, DOMAIN = 1,
CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)
clusterEvalQ(cluster, dbSendQuery(con1, "COMMIT;"))
stopCluster(cl = cluster)
}
lapply(dbListResults(con), dbClearResult)
dbDisconnect(con)
return (TRUE)
}
readPath <- "~/"
writePath <- "~/"
## Collect arguments
args <- commandArgs(TRUE)
## Default setting when no arguments passed
if(length(args) < 2) {
args <- c("--help")
} else {
## Evaluate arguments
for (a in 2:length(args)){
eval(parse(text = args[a]))
}
}
## Help section
if("--help" %in% args) {
cat("
TCGA Parser help page
All arguments will be evaluated as is, in the specified order:
The arguments can be used to define variables and call functions.
For further information about functions and variables see the TCGA Parser documentation.
readPath and writePath are \"~/\" by default.
Examples:
Establishes the path from which files are read.
\"readPath <- \\\"$PATH\\\"\"
Establishes the path where files will be written as the readPath.
\"writePath <- readPath\"
Downloads all the colon adenocarcinoma Illumina Infinium Human DNA Methylation 450 arrays data
from the TCGA.
\"download(\\\"coad\\\", \\\"humanmethylation450\\\")\"
--help      - Display this help page
\n")
}
init("coad","humanmethylation450")
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "_probeinfo(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
classes <- sapply(probeinfo, class)
a <- probeinfo[3, , drop = FALSE]
View(a)
a <- probeinfo[,3 , drop = FALSE]
View(a)
a$asdf <- apply(a, is.numeric)
a$asdf <- apply(a, 1, is.numeric)
View(a)
sapply(a, class)
a$Closest_TSS[[1]]
probeinfo$Distance_closest_TSS[[1]]
probeinfo$start[[1]]
asasa<-as.numeric(probeinfo$Closest_TSS_gene_name)
head(asasa)
em(asasa)
rm(asasa)
asasa<-as.numeric(probeinfo$Closest_TSS)
head(asasa)
head(probeinfo$Closest_TSS)
probeinfo$Closest_TSS[1]
probeinfo$Closest_TSS[1][2]
probeinfo$Closest_TSS[42758]
probeinfo$Closest_TSS[42759]
probeinfo$probe[1]
annotations <- getDataframe(
"www.ncbi.nlm.nih.gov//geo/query/acc.cgi?mode=raw&is_datatable=true&acc=GPL16304&id=47833&db=GeoDb_blob89"
)
sapply(annotations, class)
asdf<-apply(probeinfo[,3,drop=FALSE], 1, as.numeric)
warnings()
head(asdf)
is.na(asdf)
sum(is.na(asdf))
row(is.na(asdf))
rownames(is.na(asdf))
subset(asdf, asdf=NA)
as.data.frame(asdf)
asdf<-as.data.frame(asdf)
View(asdf)
subset(asdf, asdf$asdf=NA)
subset(asdf, asdf$asdf=="NA")
asdf$asdf
subset(asdf, asdf[,1,drop=FALSE]=="NA")
subset(asdf, asdf[1,,drop=FALSE]=="NA")
subset(asdf, is.na(asdf$asdf))
subset(asdf, is.na(asdf[,1,drop=FALSE]))
subset(asdf, is.na)
subset(asdf, apply(asdf$asdf, 1,is.na))
apply(asdf$asdf,1,is.na)
sum(asdf$asdf)
asdf <- as.numeric(probeinfo$Closest_TSS)
head(asdf)
class(asdf$asdf)
asdf <- apply(probeinfo$Closest_TSS, 1, as.numeric)
asdf <- apply(probeinfo[,3,drop=FALSE], 1, as.numeric)
is.na(asdf)
which(is.na(asdf))
probeinfo$Closest_TSS[18001]
probeinfo$Closest_TSS[18000]
probeinfo$Distance_closest_TSS[18000]
59854288-59854523
2*117
probeinfo$Closest_TSS_gene_name[18000]
probeinfo$Closest_TSS_gene_name[18001]
classes <- sapply(probeinfo, class)
sapply(probeinfo, class)
sapply(probeinfo, class)[1]
classes[1]
classes[4]
print(classes[4])
paste0("jh", classes[4])
sapply(annotations, classes)
table(probeinfo$percentGC)
for (i in 1:length(colnames(probeinfo))){
switch(classes[i],
factor = {
n <- max(apply(probeinfo[,i, drop = FALSE], 1, nchar))
new <- paste0(colnames(probeinfo)[i]," VARCHAR(", n, "),")
},
integer = {
new <- paste0(colnames(probeinfo)[i]," INTEGER,")
},
numeric = {
new <- paste0(colnames(probeinfo)[i]," NUMERIC,")
}
)
code <- paste0(code, new)
}
code <- paste0(code, paste0("CONSTRAINT pk_", cancerName, "_", arrayName, "_",
colnames(probeinfo)[1], "PRIMARY KEY (", colnames(probeinfo)[1],"), "))
code
library("roxygen2", lib.loc="/software/FC14/general/R-2.15.2/lib64/R/library")
roxygenise(".")
