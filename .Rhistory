cancerName, ".", arrayName, "_probeinfo(probe));"))
write(code,  paste0(writePath, "/", "createTable.txt"))
return (code)
}
#' Do PostgreSQL table correlations
#'
#' Do correlations of tables stored in PostgreSQL and store significant correlations
#' in another PostrgreSQL table.
#'
#' @include init
#' @usage corFromTableToTable(drv, ..., from.query = NULL, and.query = NULL,
#' to.table = NULL, stdev.threshold.from = 0, stdev.threshold.and = 0, pval.threshold = 1, nthreads = 1)
#' @details Requires parallel package.
#'  drv
#'    A character string specifying the database management system driver.
#'  ...
#'    Arguments needed to connect to the database, such as user, password, dbname, host, port, etc.
#'  from.query
#'    PostgreSQL statement to select or filter the data in a specified PostgreSQL table
#'    for correlations.
#'  and.query
#'    PostgreSQL statement to select or filter the data in a second specified PostgreSQL table
#'    for correlations.
#'  to.table
#'    PostgreSQL table where the significant correlations will be written.
#'  stdev.threshold.from
#'    Filters out all rows containing values with lower standard deviation than the specified threshold
#'    (in from.query).
#'  stdev.threshold.and
#'    Filters out all rows containing values with lower standard deviation than the specified threshold
#'    (in and.query).
#'  pval.threshold
#'    Correlations with a p-value higher than this threshold will be considered significant and registered
#'    in to.table.
#'  nthreads
#'    Number of threads this functions will use.
corFromTableToTable <- function (drv, ..., from.query = NULL, and.query = NULL,
to.table = NULL, stdev.threshold.from = 0,
stdev.threshold.and = 0, pval.threshold = 1, nthreads = 1){
require(parallel)
if (exists("dbConnect") == FALSE){
require(RPostgreSQL)
}
con <- dbConnect(drv, ...)
if (is.null(con)) {
stop("supply a connection")
}
if (is.null(from.query)) {
stop("supply a table to read from")
}
if (is.null(to.table)) {
stop("supply a table to write to")
}
if (!(is.numeric(stdev.threshold.from))){
stop("'stdev.threshold.from' must be numeric")
}
if (!(is.numeric(stdev.threshold.and))){
stop("'stdev.threshold.and' must be numeric")
}
if (!(is.numeric(pval.threshold))){
stop("'pval.threshold' must be numeric")
}
# Prepare and filter dataframes
filter <- function (dataframe, stdev){
system('echo Filtering started $(date)')
startrow <- nrow(dataframe)
df <- na.exclude(dataframe)
noNArow <- nrow(df)
df$sd <- apply(df[,-1], 1, sd, na.rm=TRUE)
df <- subset(df, sd > stdev)
df <- df[,-length(df)]
endrow <- nrow(df)
diffrow <- startrow - endrow
noNA <- startrow - noNArow
cat(paste('\n', diffrow, 'probes filtered out.', noNA, 'probes contained NAs\n'))
system('echo Filtering ended $(date)')
return (df)
}
# Do all probe correlations
correlation <- function (x, y, to.table, pval.threshold){
a <- as.numeric(x[-1])
b <- as.numeric(y[-1])
corr <- cor.test (a, b, method = "spearman")
count <<- count + 1
if (corr$p.value <= pval.threshold) {
x_probe_name <- x[1]
y_probe_name <- y[1]
if (!init){
system('echo Initializing connection with PostgreSQL $(date)')
con1 <<- dbConnect(drv, ...)
dbSendQuery(con1, "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;")
dbSendQuery(con1, 'BEGIN;')
init <<- TRUE
}
# because the pvalue is defined as float(4) in postgres
if  (corr$p.value < 5.60519e-45) corr$p.value <- 0
statement <- paste0("INSERT INTO ", to.table, " VALUES ('",
x_probe_name, "', '", y_probe_name, "', ",
corr$estimate, ",", corr$p.value, ");")
dbSendQuery(con1, statement)
}
if (count >= 100000){
system('echo 100000 counts done $(date)')
dbSendQuery(con1, 'COMMIT;')
dbSendQuery(con1, 'BEGIN;')
count <<- 0
}
}
apply2 <- function (X, Y, DOMAIN, CTION, ...) {
CTION <- match.fun(CTION)
dl <- length(dim(Y))
if (!dl)
stop("dim(Y) must have a positive length")
if (is.object(Y))
Y <- if (dl == 2L)
as.matrix(Y)
else as.array(Y)
d <- dim(Y)
dn <- dimnames(Y)
ds <- seq_len(dl)
if (is.character(DOMAIN)) {
if (is.null(dnn <- names(dn)))
stop("'Y' must have named dimnames")
DOMAIN <- match(DOMAIN, dnn)
if (any(is.na(DOMAIN)))
stop("not all elements of 'DOMAIN' are names of dimensions")
}
s.call <- ds[-DOMAIN]
s.ans <- ds[DOMAIN]
d.call <- d[-DOMAIN]
d.ans <- d[DOMAIN]
dn.call <- dn[-DOMAIN]
dn.ans <- dn[DOMAIN]
d2 <- prod(d.ans)
if (d2 == 0L) {
newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call),
1L))
ans <- CTION(if (length(d.call) < 2L)
newY[, 1]
else array(X,newY[, 1L], d.call, dn.call), ...)
return(if (is.null(ans)) ans else if (length(d.ans) <
2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))
}
newY <- aperm(Y, c(s.call, s.ans))
dim(newY) <- c(prod(d.call), d2)
ans <- vector("list", d2)
if (length(d.call) < 2L) {
if (length(dn.call))
dimnames(newY) <- c(dn.call, list(NULL))
for (i in 1L:d2) {
tmp <- CTION(X,newY[, i], ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
}
else for (i in 1L:d2) {
tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
ans.list <- is.recursive(ans[[1L]])
l.ans <- length(ans[[1L]])
ans.names <- names(ans[[1L]])
if (!ans.list)
ans.list <- any(unlist(lapply(ans, length)) != l.ans)
if (!ans.list && length(ans.names)) {
all.same <- vapply(ans, function(Y) identical(names(Y),
ans.names), NA)
if (!all(all.same))
ans.names <- NULL
}
len.a <- if (ans.list)
d2
else length(ans <- unlist(ans, recursive = FALSE))
if (length(DOMAIN) == 1L && len.a == d2) {
names(ans) <- if (length(dn.ans[[1L]]))
dn.ans[[1L]]
return(ans)
}
if (len.a == d2)
return(array(ans, d.ans, dn.ans))
if (len.a && len.a%%d2 == 0L) {
if (is.null(dn.ans))
dn.ans <- vector(mode = "list", length(d.ans))
dn.ans <- c(list(ans.names), dn.ans)
return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans,
is.null, NA))) dn.ans))
}
return(ans)
}
apply2half <- function (X, Y, DOMAIN, CTION, ...) {
rowmatch <- match(X[1], Y[,1])
if (rowmatch < nrow (Y)){
Y <- Y[((1L+rowmatch):nrow(Y)),]
CTION <- match.fun(CTION)
dl <- length(dim(Y))
if (!dl)
stop("dim(Y) must have a positive length")
if (is.object(Y))
Y <- if (dl == 2L)
as.matrix(Y)
else as.array(Y)
d <- dim(Y)
dn <- dimnames(Y)
ds <- seq_len(dl)
if (is.character(DOMAIN)) {
if (is.null(dnn <- names(dn)))
stop("'Y' must have named dimnames")
DOMAIN <- match(DOMAIN, dnn)
if (any(is.na(DOMAIN)))
stop("not all elements of 'DOMAIN' are names of dimensions")
}
s.call <- ds[-DOMAIN]
s.ans <- ds[DOMAIN]
d.call <- d[-DOMAIN]
d.ans <- d[DOMAIN]
dn.call <- dn[-DOMAIN]
dn.ans <- dn[DOMAIN]
d2 <- prod(d.ans)
if (d2 == 0L) {
newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call),
1L))
ans <- CTION(if (length(d.call) < 2L)
newY[, 1]
else array(X,newY[, 1L], d.call, dn.call), ...)
return(if (is.null(ans)) ans else if (length(d.ans) <
2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))
}
newY <- aperm(Y, c(s.call, s.ans))
dim(newY) <- c(prod(d.call), d2)
ans <- vector("list", d2)
if (length(d.call) < 2L) {
if (length(dn.call))
dimnames(newY) <- c(dn.call, list(NULL))
for (i in 1L:d2) {
tmp <- CTION(X,newY[, i], ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
}
else for (i in 1L:d2) {
tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)
if (!is.null(tmp))
ans[[i]] <- tmp
}
ans.list <- is.recursive(ans[[1L]])
l.ans <- length(ans[[1L]])
ans.names <- names(ans[[1L]])
if (!ans.list)
ans.list <- any(unlist(lapply(ans, length)) != l.ans)
if (!ans.list && length(ans.names)) {
all.same <- vapply(ans, function(Y) identical(names(Y),
ans.names), NA)
if (!all(all.same))
ans.names <- NULL
}
len.a <- if (ans.list)
d2
else length(ans <- unlist(ans, recursive = FALSE))
if (length(DOMAIN) == 1L && len.a == d2) {
names(ans) <- if (length(dn.ans[[1L]]))
dn.ans[[1L]]
return(ans)
}
if (len.a == d2)
return(array(ans, d.ans, dn.ans))
if (len.a && len.a%%d2 == 0L) {
if (is.null(dn.ans))
dn.ans <- vector(mode = "list", length(d.ans))
dn.ans <- c(list(ans.names), dn.ans)
return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans,
is.null, NA))) dn.ans))
}
return(ans)
}
}
# Get dataframes from the database
cat('\nGetting data from database ')
system('date')
# this fetches the sample names
# x_rs <- dbGetQuery(con,
#                    "SELECT 'SELECT ' || array_to_string(ARRAY(SELECT c.column_name
#                     FROM information_schema.columns As c
#                     WHERE c.table_name = 'humanmethylation450'
#                       AND c.table_schema = 'coad'
#                       AND  c.column_name ~ '^TCGA_'
#                     ), ',') || ' FROM humanmethylation450 WHERE chromosome = 22' AS sqlstmt; ")
x_rs <-  dbGetQuery(con, from.query)
if (!is.null(and.table)) {
y_rs <- dbGetQuery(con, and.query)
}
system('echo Finished getting data from database $(date)')
x_rs <- filter(x_rs, stdev.threshold.from)
if (!is.null(and.table)) {
y_rs <- filter(y_rs, stdev.threshold.and)
}
system('echo Making clusters $(date)')
cluster <- makeCluster(nthreads)
clusterExport(cluster, "connect")
clusterEvalQ(cluster, library(RPostgreSQL))
clusterEvalQ(cluster, init <- FALSE)
clusterEvalQ(cluster, count <- 0)
system('echo Starting parallel apply $(date)')
if (!is.null(and.table)) {
parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2, Y = y_rs, DOMAIN = 1,
CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)
clusterEvalQ(cluster, dbSendQuery(con1, "COMMIT;"))
stopCluster(cl = cluster)
} else {
parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2half, Y = x_rs, DOMAIN = 1,
CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)
clusterEvalQ(cluster, dbSendQuery(con1, "COMMIT;"))
stopCluster(cl = cluster)
}
lapply(dbListResults(con), dbClearResult)
dbDisconnect(con)
return (TRUE)
}
readPath <- "~/"
writePath <- "~/"
## Collect arguments
args <- commandArgs(TRUE)
## Default setting when no arguments passed
if(length(args) < 2) {
args <- c("--help")
} else {
## Evaluate arguments
for (a in 2:length(args)){
eval(parse(text = args[a]))
}
}
## Help section
if("--help" %in% args) {
cat("
TCGA Parser help page
All arguments will be evaluated as is, in the specified order:
The arguments can be used to define variables and call functions.
For further information about functions and variables see the TCGA Parser documentation.
readPath and writePath are \"~/\" by default.
Examples:
Establishes the path from which files are read.
\"readPath <- \\\"$PATH\\\"\"
Establishes the path where files will be written as the readPath.
\"writePath <- readPath\"
Downloads all the colon adenocarcinoma Illumina Infinium Human DNA Methylation 450 arrays data
from the TCGA.
\"download(\\\"coad\\\", \\\"humanmethylation450\\\")\"
--help      - Display this help page
\n")
}
init("coad", "humanmethylation450")
archiveList <- getLinks(paste0(accessRoot, cancerName, arrayPath), archiveRegexpr)
fileList <- getLinks(paste0(accessRoot, cancerName, arrayPath, archiveList[[1]][[1]]), fileRegexpr)
reference <- getDataframe(paste0(accessRoot, cancerName, arrayPath, archiveList[[1]][[1]],
fileList[[1]][[1]]))
reference <- fixDataframe(reference, arrayName)
reference[colnames(reference) == value] <- NULL
reference[colnames(reference) == "Gene_Symbol"] <- NULL
reference[colnames(reference) == "Genomic_Coordinate"] <- NULL
annotations <- getDataframe(
"www.ncbi.nlm.nih.gov//geo/query/acc.cgi?mode=raw&is_datatable=true&acc=GPL16304&id=47833&db=GeoDb_blob89"
)
colnames(annotations) == "Closest_TSS"
id <- annotations[colnames(annotations) == "Closest_TSS"]
View(id)
reference <- cbind(reference, annotations[colnames(annotations) == "Closest_TSS"])
View(reference)
View(reference)
reference <- cbind(reference, annotations[colnames(annotations) == "Distance_closest_TSS"])
reference <- cbind(reference, annotations[colnames(annotations) == "Closest_TSS_gene_name"])
require("FDb.InfiniumMethylation.hg19")
annotations <- get450k()
annotations <- as.data.frame(annotations)
annotations <- annotations[order(row.names(annotations)),]
annotations[colnames(annotations) == "seqnames"] <- NULL
annotations[colnames(annotations) == "probeTarget"] <- NULL
annotations <- annotations[-grep("rs", rownames(annotations)),]# Removes all the rs probes.
reference <- cbind(reference, annotations)
write.table(reference, file = paste0(writePath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
sep = "\t", quote = FALSE)
gsub(" ","_", colnames(reference))
colnames(reference) <- gsub(" ","_", colnames(reference))
write.table(reference, file = paste0(writePath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
sep = "\t", quote = FALSE)
length("asdf")
nchar("asdf")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
View(probeinfo)
View(probeinfo)
head(probeinfo[,1])
nchar(probeinfo[,1])
apply(probeinfo[,1], 1, nchar)
apply(probeinfo[,1], 1, nchar, na.rm=TRUe)
apply(probeinfo[,1], 1, nchar, na.rm=TRUE)
apply(probeinfo[,1], 2, nchar, na.rm=TRUE)
apply(probeinfo[,1], 1, nchar, na.rm=TRUE)
View(annotations)
View(probeinfo)
probeinfo[,1]
probeinfo[,1][[1]]
reference[colnames(reference) == "Composite_Element_REF"]
apply(reference[colnames(reference) == "Composite_Element_REF"], 1, nchar)
max(apply(reference[colnames(reference) == "Composite_Element_REF"], 1, nchar))
varchar <- max(apply(reference[colnames(reference) == "Composite_Element_REF"], 1, nchar))
varchar <- "16"
16L
varchar <- max(apply(reference[colnames(reference) == "Composite_Element_REF"], 1, nchar))
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "(")
probe <- paste0("probe VARCHAR(", varchar, "),")
code <- paste0(code, probe)
return (code)
code
max(apply(reference[,1, drop = FALSE], 1, nchar))
init("coad", "illuminahiseq_rnaseqv2")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
archiveList <- getLinks(paste0(accessRoot, cancerName, arrayPath), archiveRegexpr)
fileList <- getLinks(paste0(accessRoot, cancerName, arrayPath, archiveList[[1]][[1]]), fileRegexpr)
reference <- getDataframe(paste0(accessRoot, cancerName, arrayPath, archiveList[[1]][[1]],
fileList[[1]][[1]]))
reference <- fixDataframe(reference, arrayName)
reference[colnames(reference) == value] <- NULL
reference[colnames(reference) == "raw_counts"] <- NULL
reference[colnames(reference) == "median_length_normalized"] <- NULL
exon <- "^chr([0123456789XY]+):([[:digit:]]*)-([[:digit:]]*):([[:punct:]])$"
reference$chromosome <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\1", x)))
reference$start <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\2", x)))
reference$end <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\3", x)))
reference$strand <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\4", x)))
View(reference)
write.table(reference, file = paste0(writePath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
sep = "\t", quote = FALSE)
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
View(probeinfo)
varchar <- max(apply(reference[,1, drop = FALSE], 1, nchar))
apply(reference[,1, drop = FALSE], 1, nchar)
init("coad","humanmethylation450")
init("coad","illuminahiseq_rnaseqv2")
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "probeinfo(")
View(probeinfo)
colnames(probeinfo)
colnames(probeinfo)[1]
probe <- paste0(colnames(probeinfo)[1]," VARCHAR(", varchar, "),")
code <- paste0(code, probe)
code
table(probeinfo[,1,drop = FALSE])
table(probeinfo[,2,drop = FALSE])
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "_probeinfo(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
View(probeinfo)
for (i in 1:length(colnames(probeinfo))){
n <- max(apply(probeinfo[,i, drop = FALSE], 1, nchar))
new <- paste0(colnames(probeinfo)[i]," VARCHAR(", n, "),")
code <- paste0(code, new)
}
code
table(probeinfo[,4, drop = FALSE])
table(probeinfo[,5, drop = FALSE])
View(probeinfo)
table(probeinfo[,2, drop = FALSE])
exon <- "^chr(.*):([[:digit:]]*)-([[:digit:]]*):([[:punct:]])$"
reference$chromosome <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\1", x)))
View(reference)
table(reference[,2, drop = FALSE])
reference$start <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\2", x)))
reference$end <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\3", x)))
reference$strand <- apply(reference[,1, drop = FALSE], 2,
function(x) as.character(gsub(exon, "\\4", x)))
write.table(reference, file = paste0(writePath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
sep = "\t", quote = FALSE)
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "_probeinfo(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
for (i in 1:length(colnames(probeinfo))){
n <- max(apply(probeinfo[,i, drop = FALSE], 1, nchar))
new <- paste0(colnames(probeinfo)[i]," VARCHAR(", n, "),")
code <- paste0(code, new)
}
code <- paste0(code, paste0("CONSTRAINT pk_", cancerName, "_probe PRIMARY KEY (",
colnames(probeinfo)[1],"), "))
code
colnames(probeinfo)[1]
init("coad", "humanmethylation450")
code <- paste0("CREATE TABLE ", cancerName, ".", arrayName, "_probeinfo(")
probeinfo <- read.table(paste0(readPath, "/", cancerName, "_dataframe_", arrayName, ".txt"),
header = TRUE, sep = "\t")
View(probeinfo)
colnames(probeinfo)[colnames(probeinfo) == "Composite_Element_REF"] <- "probe"
View(probeinfo)
for (i in 1:length(colnames(probeinfo))){
n <- max(apply(probeinfo[,i, drop = FALSE], 1, nchar))
new <- paste0(colnames(probeinfo)[i]," VARCHAR(", n, "),")
code <- paste0(code, new)
}
code
library("roxygen2", lib.loc="/software/FC14/general/R-3.0.2/lib64/R/library")
detach("package:roxygen2", unload=TRUE)
library("roxygen2", lib.loc="/software/FC14/general/R-3.0.2/lib64/R/library")
detach("package:roxygen2", unload=TRUE)
library("roxygen2", lib.loc="/software/FC14/general/R-3.0.2/lib64/R/library")
library("roxygen2", lib.loc="/software/FC14/general/R-2.15.2/lib64/R/library")
roxygenise(".")
