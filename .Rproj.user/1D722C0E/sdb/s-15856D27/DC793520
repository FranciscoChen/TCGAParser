{
    "contents" : "#!/usr/env Rscript\n\nlibrary(RPostgreSQL)\nlibrary(parallel)\n\n#usage <- function(x) {\n#  cat('\\nUSAGE:\\n')\n#  cat('  Rscript DatabaseConnections.R <num_cores> <from_table> <to_table>\\n')\n#}\n\nconnect <- function(){\n  dbhost = \"locke\"\n  drv <- dbDriver(\"PostgreSQL\")\n  dbname <-\"meth_correlations\"\n  dbuser <- \"fchen\"\n  dbpass <- \"UNpasswordMAS\"\n  dbport <- 5432\n  return (dbConnect(drv, host=dbhost, port=dbport, dbname=dbname, user=dbuser, password=dbpass))\n}\n\ndisconnect <- function(con){\n  lapply(dbListResults(con), dbClearResult)\n  dbDisconnect(con)\n}\n\n\n\n\ncorFromTableToTable <- function (con = NULL, from.table = NULL, from.query = NULL,\n                                 and.table = NULL, and.query = NULL, primary.key = NULL, \n                                 to.table = NULL, stdev.threshold.from = 0, \n                                 stdev.threshold.and = 0, pval.threshold = 1, nthreads = 1){\n  require(parallel)\n  if (is.null(con)) {\n    stop(\"supply a connection\")\n  }\n  if (is.null(from.table)) {\n    stop(\"supply a table to read from\")\n  }\n  if (is.null(primary.key)) {\n    stop(\"supply a name for the primary key column\")\n  }\n  if (is.null(to.table)) {\n    stop(\"supply a table to write to\")\n  }\n  if (!(is.numeric(stdev.threshold.from))){\n    stop(\"'stdev.threshold.from' must be numeric\")\n  }\n  if (!(is.numeric(stdev.threshold.and))){\n    stop(\"'stdev.threshold.and' must be numeric\")\n  }\n  if (!(is.numeric(pval.threshold))){\n    stop(\"'pval.threshold' must be numeric\")\n  }\n  # Prepare and filter dataframes\n  filter <- function (dataframe, stdev){\n    system('echo Filtering started $(date)')\n    \n    startrow <- nrow(dataframe)\n    df <- na.exclude(dataframe)\n    noNArow <- nrow(df)\n    df$sd <- apply(df[,-1], 1, sd, na.rm=TRUE)\n    df <- subset(df, sd > stdev)\n    df <- df[,-length(df)]\n    endrow <- nrow(df)\n    diffrow <- startrow - endrow\n    noNA <- startrow - noNArow\n    cat(paste('\\n', diffrow, 'probes filtered out.', noNA, 'probes contained NAs\\n'))\n    \n    system('echo Filtering ended $(date)')\n    \n    return (df)\n  }\n  \n  # Do all probe correlations\n  correlation <- function (x, y, to.table, pval.threshold){\n    a <- as.numeric(x[-1])\n    b <- as.numeric(y[-1])\n    corr <- cor.test (a, b, method = \"spearman\")\n    count <<- count + 1\n    if (corr$p.value <= pval.threshold) {\n      x_probe_name <- x[1]\n      y_probe_name <- y[1]\n      if (!init){\n        system('echo Initializing connection with PostgreSQL $(date)')\n        con1 <<- connect()\n        dbSendQuery(con1, \"SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\")\n        dbSendQuery(con1, 'BEGIN;')\n        init <<- TRUE\n      }\n      \n      # because the pvalue is defined as float(4) in postgres\n      if  (corr$p.value < 5.60519e-45) corr$p.value <- 0\n      \n      statement <- paste(\"INSERT INTO \", to.table, \" VALUES ('\",\n                         x_probe_name, \"', '\", y_probe_name, \"', \",\n                         corr$estimate, \",\", corr$p.value, \");\", sep =  \"\")\n      \n      dbSendQuery(con1, statement)\n    }\n    if (count >= 100000){\n      system('echo 100000 counts done $(date)')\n      dbSendQuery(con1, 'COMMIT;')\n      dbSendQuery(con1, 'BEGIN;')\n      count <<- 0\n    }\n  }\n  \n  apply2 <- function (X, Y, DOMAIN, CTION, ...) {\n    CTION <- match.fun(CTION)\n    dl <- length(dim(Y))\n    if (!dl) \n      stop(\"dim(Y) must have a positive length\")\n    if (is.object(Y)) \n      Y <- if (dl == 2L) \n        as.matrix(Y)\n    else as.array(Y)\n    d <- dim(Y)\n    dn <- dimnames(Y)\n    ds <- seq_len(dl)\n    if (is.character(DOMAIN)) {\n      if (is.null(dnn <- names(dn))) \n        stop(\"'Y' must have named dimnames\")\n      DOMAIN <- match(DOMAIN, dnn)\n      if (any(is.na(DOMAIN))) \n        stop(\"not all elements of 'DOMAIN' are names of dimensions\")\n    }\n    s.call <- ds[-DOMAIN]\n    s.ans <- ds[DOMAIN]\n    d.call <- d[-DOMAIN]\n    d.ans <- d[DOMAIN]\n    dn.call <- dn[-DOMAIN]\n    dn.ans <- dn[DOMAIN]\n    d2 <- prod(d.ans)\n    if (d2 == 0L) {\n      newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call), \n                                                   1L))\n      ans <- CTION(if (length(d.call) < 2L) \n        newY[, 1]\n        else array(X,newY[, 1L], d.call, dn.call), ...)\n      return(if (is.null(ans)) ans else if (length(d.ans) < \n                                              2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))\n    }\n    newY <- aperm(Y, c(s.call, s.ans))\n    dim(newY) <- c(prod(d.call), d2)\n    ans <- vector(\"list\", d2)\n    if (length(d.call) < 2L) {\n      if (length(dn.call)) \n        dimnames(newY) <- c(dn.call, list(NULL))\n      for (i in 1L:d2) {\n        tmp <- CTION(X,newY[, i], ...)\n        if (!is.null(tmp)) \n          ans[[i]] <- tmp\n      }\n    }\n    else for (i in 1L:d2) {\n      tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)\n      if (!is.null(tmp)) \n        ans[[i]] <- tmp\n    }\n    ans.list <- is.recursive(ans[[1L]])\n    l.ans <- length(ans[[1L]])\n    ans.names <- names(ans[[1L]])\n    if (!ans.list) \n      ans.list <- any(unlist(lapply(ans, length)) != l.ans)\n    if (!ans.list && length(ans.names)) {\n      all.same <- vapply(ans, function(Y) identical(names(Y), \n                                                    ans.names), NA)\n      if (!all(all.same)) \n        ans.names <- NULL\n    }\n    len.a <- if (ans.list) \n      d2\n    else length(ans <- unlist(ans, recursive = FALSE))\n    if (length(DOMAIN) == 1L && len.a == d2) {\n      names(ans) <- if (length(dn.ans[[1L]])) \n        dn.ans[[1L]]\n      return(ans)\n    }\n    if (len.a == d2) \n      return(array(ans, d.ans, dn.ans))\n    if (len.a && len.a%%d2 == 0L) {\n      if (is.null(dn.ans)) \n        dn.ans <- vector(mode = \"list\", length(d.ans))\n      dn.ans <- c(list(ans.names), dn.ans)\n      return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans, \n                                                              is.null, NA))) dn.ans))\n    }\n    return(ans)\n  }\n  \n  apply2half <- function (X, Y, DOMAIN, CTION, ...) {\n    rowmatch <- match(X[1], Y[,1])\n    if (rowmatch < nrow (Y)){\n      Y <- Y[((1L+rowmatch):nrow(Y)),]\n      CTION <- match.fun(CTION)\n      dl <- length(dim(Y))\n      if (!dl) \n        stop(\"dim(Y) must have a positive length\")\n      if (is.object(Y)) \n        Y <- if (dl == 2L) \n          as.matrix(Y)\n      else as.array(Y)\n      d <- dim(Y)\n      dn <- dimnames(Y)\n      ds <- seq_len(dl)\n      if (is.character(DOMAIN)) {\n        if (is.null(dnn <- names(dn))) \n          stop(\"'Y' must have named dimnames\")\n        DOMAIN <- match(DOMAIN, dnn)\n        if (any(is.na(DOMAIN))) \n          stop(\"not all elements of 'DOMAIN' are names of dimensions\")\n      }\n      s.call <- ds[-DOMAIN]\n      s.ans <- ds[DOMAIN]\n      d.call <- d[-DOMAIN]\n      d.ans <- d[DOMAIN]\n      dn.call <- dn[-DOMAIN]\n      dn.ans <- dn[DOMAIN]\n      d2 <- prod(d.ans)\n      if (d2 == 0L) {\n        newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call), \n                                                     1L))\n        ans <- CTION(if (length(d.call) < 2L) \n          newY[, 1]\n          else array(X,newY[, 1L], d.call, dn.call), ...)\n        return(if (is.null(ans)) ans else if (length(d.ans) < \n                                                2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))\n      }\n      newY <- aperm(Y, c(s.call, s.ans))\n      dim(newY) <- c(prod(d.call), d2)\n      ans <- vector(\"list\", d2)\n      if (length(d.call) < 2L) {\n        if (length(dn.call)) \n          dimnames(newY) <- c(dn.call, list(NULL))\n        for (i in 1L:d2) {\n          tmp <- CTION(X,newY[, i], ...)\n          if (!is.null(tmp)) \n            ans[[i]] <- tmp\n        }\n      }\n      else for (i in 1L:d2) {\n        tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)\n        if (!is.null(tmp)) \n          ans[[i]] <- tmp\n      }\n      ans.list <- is.recursive(ans[[1L]])\n      l.ans <- length(ans[[1L]])\n      ans.names <- names(ans[[1L]])\n      if (!ans.list) \n        ans.list <- any(unlist(lapply(ans, length)) != l.ans)\n      if (!ans.list && length(ans.names)) {\n        all.same <- vapply(ans, function(Y) identical(names(Y), \n                                                      ans.names), NA)\n        if (!all(all.same)) \n          ans.names <- NULL\n      }\n      len.a <- if (ans.list) \n        d2\n      else length(ans <- unlist(ans, recursive = FALSE))\n      if (length(DOMAIN) == 1L && len.a == d2) {\n        names(ans) <- if (length(dn.ans[[1L]])) \n          dn.ans[[1L]]\n        return(ans)\n      }\n      if (len.a == d2) \n        return(array(ans, d.ans, dn.ans))\n      if (len.a && len.a%%d2 == 0L) {\n        if (is.null(dn.ans)) \n          dn.ans <- vector(mode = \"list\", length(d.ans))\n        dn.ans <- c(list(ans.names), dn.ans)\n        return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans, \n                                                                is.null, NA))) dn.ans))\n      }\n      return(ans) \n    }\n  }\n  # Get dataframes from the database\n  cat('\\nGetting data from database ')\n  system('date')\n  #x_rs <- dbGetQuery(con, paste('SELECT * FROM', from.table))\n\n  # this fetches the sample names\n# x_rs <- dbGetQuery(con,\n#                    \"SELECT 'SELECT ' || array_to_string(ARRAY(SELECT 'o' || '.' || c.column_name\n#                     FROM information_schema.columns As c\n#                     WHERE c.table_name = 'humanmethylation450' \n#                       AND c.table_schema = 'coad'\n#                       AND  c.column_name NOT IN('chromosome', 'genomic_coordinate_hg19')\n#                     ), ',') || ' FROM humanmethylation450 AS data' AS sqlstmt; \")\n\n\n\n  x_rs <-  dbGetQuery(con, from.query)\n                     \n  if (!is.null(and.table)) {\n    y_rs <- dbGetQuery(con, and.query)\n    }\n  system('echo Finished getting data from database $(date)')\n  \n  \n  x_rs <- filter(x_rs, stdev.threshold.from)\n  if (!is.null(and.table)) {\n    y_rs <- filter(y_rs, stdev.threshold.and) \n  }\n\n  \n  system('echo Making clusters $(date)')\n  cluster <- makeCluster(nthreads)\n  clusterExport(cluster, \"connect\")\n  clusterEvalQ(cluster, library(RPostgreSQL))\n  clusterEvalQ(cluster, init <- FALSE)\n  clusterEvalQ(cluster, count <- 0)\n\n  system('echo Starting parallel apply $(date)')\n  \n  if (!is.null(and.table)) {\n    parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2, Y = y_rs, DOMAIN = 1,\n                  CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)\n    clusterEvalQ(cluster, dbSendQuery(con1, \"COMMIT;\"))\n    stopCluster(cl = cluster)\n  } else {\n    parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2half, Y = x_rs, DOMAIN = 1,\n                  CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)\n    clusterEvalQ(cluster, dbSendQuery(con1, \"COMMIT;\"))\n    stopCluster(cl = cluster)\n  }\n  return (TRUE)\n}\n\n#\n\n#args <- commandArgs(trailingOnly = TRUE)\n\n#if (length(args) < 2) {\n#  usage()\n#  stop()\n#}\n\n#NTHREADS <- args[1]\n#FROM_TABLE <- args[2]\n#TO_TABLE <- args[3]\n\nNTHREADS <- 8\n\ncon <- connect ()\n\ncorFromTableToTable(con = con,\n                    #from.table = FROM_TABLE,\n                    from.table = 'blablabla',\n                    and.table = NULL,\n                    primary.key = \"probe\",\n                    #to.table = TO_TABLE,\n                    to.table = 'chr7.correlations',\n                    stdev.threshold.from = 0,\n                    stdev.threshold.and = 0,\n                    pval.threshold = 4)\n\n#corFromTableToTable(con = con, from.table = \"coad.humanmethylation450\", and.table = NULL, primary.key = \"probe\", to.table = \"coad.filtered_correlations\", stdev.threshold.from = 0.05, stdev.threshold.and = 0, pval.threshold = 0.05)\ndisconnect(con)\n\ncat('\\nDone ')\nsystem('date')\n",
    "created" : 1396960868392.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "20|28|23|0|\n108|49|189|2|\n191|53|276|2|\n",
    "hash" : "3420675856",
    "id" : "DC793520",
    "lastKnownWriteTime" : 1396968211,
    "path" : "/imppc/labs/maplab/fchen/DatabaseConnection_3.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}