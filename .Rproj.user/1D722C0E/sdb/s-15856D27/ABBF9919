{
    "contents" : "#!/usr/env Rscript\n\nlibrary(RPostgreSQL)\nlibrary(parallel)\n\n#usage <- function(x) {\n#  cat('\\nUSAGE:\\n')\n#  cat('  Rscript DatabaseConnections.R <num_cores> <from_table> <to_table>\\n')\n#}\n\nconnect <- function(){\n  dbhost = \"locke\"\n  drv <- dbDriver(\"PostgreSQL\")\n  dbname <-\"meth_correlations\"\n  dbuser <- \"fchen\"\n  dbpass <- \"UNpasswordMAS\"\n  dbport <- 5432\n  return (dbConnect(drv, host=dbhost, port=dbport, dbname=dbname, user=dbuser, password=dbpass))\n}\n\ndisconnect <- function(con){\n  lapply(dbListResults(con), dbClearResult)\n  dbDisconnect(con)\n}\n\ncorFromTableToTable <- function (con = NULL, from.table = NULL, \n                                 and.table = NULL, primary.key = NULL, \n                                 to.table = NULL, stdev.threshold.from = 0, \n                                 stdev.threshold.and = 0, pval.threshold = 1){\n  if (is.null(con)) {\n    stop(\"supply a connection\")\n  }\n  if (is.null(from.table)) {\n    stop(\"supply a table to read from\")\n  }\n  if (is.null(primary.key)) {\n    stop(\"supply a name for the primary key column\")\n  }\n  if (is.null(to.table)) {\n    stop(\"supply a table to write to\")\n  }\n  if (!(is.numeric(stdev.threshold.from))){\n    stop(\"'stdev.threshold.from' must be numeric\")\n  }\n  if (!(is.numeric(stdev.threshold.and))){\n    stop(\"'stdev.threshold.and' must be numeric\")\n  }\n  if (!(is.numeric(pval.threshold))){\n    stop(\"'pval.threshold' must be numeric\")\n  }\n      \n  # Get dataframes from the database\n  cat('\\nGetting data from database ')\n  system('date')\n  #x_rs <- dbGetQuery(con, paste('SELECT * FROM', from.table))\n\n  # this fetches the sample names\n# x_rs <- dbGetQuery(con,\n#                    \"SELECT 'SELECT ' || array_to_string(ARRAY(SELECT 'o' || '.' || c.column_name\n#                     FROM information_schema.columns As c\n#                     WHERE c.table_name = 'humanmethylation450' \n#                       AND c.table_schema = 'coad'\n#                       AND  c.column_name NOT IN('chromosome', 'genomic_coordinate_hg19')\n#                     ), ',') || ' FROM humanmethylation450 AS data' AS sqlstmt; \")\n\n\n\n  x_rs <-  dbGetQuery(con, \"SELECT o.probe,o.tcga_a6_2682_01a_01d_1407_05,o.tcga_a6_2684_01a_01d_1407_05,o.tcga_a6_2685_01a_01d_1407_05,o.tcga_aa_3492_01a_01d_1407_05,o.tcga_aa_3495_01a_01d_1407_05,o.tcga_aa_3502_01a_01d_1407_05,o.tcga_aa_3506_01a_01d_1407_05,o.tcga_aa_3509_01a_01d_1407_05,o.tcga_az_4313_01a_01d_1407_05,o.tcga_az_4315_01a_01d_1407_05,o.tcga_az_4614_01a_01d_1407_05,o.tcga_az_4615_01a_01d_1407_05,o.tcga_az_4684_01a_01d_1407_05,o.tcga_ca_5256_01a_01d_1407_05,o.tcga_ck_4951_01a_01d_1407_05,o.tcga_cm_4747_01a_01d_1407_05,o.tcga_a6_a565_01a_31d_a28o_05,o.tcga_a6_a566_01a_11d_a28o_05,o.tcga_a6_a567_01a_31d_a28o_05,o.tcga_a6_a56b_01a_31d_a28o_05,o.tcga_a6_a5zu_01a_11d_a28o_05,o.tcga_ad_a5ej_01a_11d_a28o_05,o.tcga_ad_a5ek_01a_11d_a28o_05,o.tcga_ay_a54l_01a_11d_a28o_05,o.tcga_nh_a50t_01a_11d_a28o_05,o.tcga_nh_a50v_01a_11d_a28o_05,o.tcga_qg_a5yv_01a_11d_a28o_05,o.tcga_qg_a5yw_01a_11d_a28o_05,o.tcga_qg_a5yx_01a_11d_a28o_05,o.tcga_qg_a5z1_01a_11d_a28o_05,o.tcga_qg_a5z2_01a_11d_a28o_05,o.tcga_a6_5659_01a_01d_1651_05,o.tcga_a6_5660_01a_01d_1651_05,o.tcga_a6_5661_01a_01d_1651_05,o.tcga_a6_5662_01a_01d_1651_05,o.tcga_a6_5665_01a_01d_1651_05,o.tcga_a6_5666_01a_01d_1651_05,o.tcga_ad_5900_01a_11d_1651_05,o.tcga_am_5820_01a_01d_1651_05,o.tcga_am_5821_01a_01d_1651_05,o.tcga_ay_5543_01a_01d_1651_05,o.tcga_az_5403_01a_01d_1651_05,o.tcga_ca_5796_01a_01d_1651_05,o.tcga_ca_5797_01a_01d_1651_05,o.tcga_ck_4947_01b_11d_1651_05,o.tcga_ck_4948_01b_11d_1651_05,o.tcga_ck_5912_01a_11d_1651_05,o.tcga_ck_5913_01a_11d_1651_05,o.tcga_ck_5914_01a_11d_1651_05,o.tcga_ck_5915_01a_11d_1651_05,o.tcga_ck_5916_01a_11d_1651_05,o.tcga_cm_5860_01a_01d_1651_05,o.tcga_cm_5861_01a_01d_1651_05,o.tcga_cm_5862_01a_01d_1651_05,o.tcga_cm_5864_01a_01d_1651_05,o.tcga_cm_5868_01a_01d_1651_05,o.tcga_cm_6161_01a_11d_1651_05,o.tcga_cm_6162_01a_11d_1651_05,o.tcga_cm_6163_01a_11d_1651_05,o.tcga_cm_6164_01a_11d_1651_05,o.tcga_cm_6165_01a_11d_1651_05,o.tcga_cm_6166_01a_11d_1651_05,o.tcga_cm_6167_01a_11d_1651_05,o.tcga_cm_6168_01a_11d_1651_05,o.tcga_cm_6169_01a_11d_1651_05,o.tcga_cm_6170_01a_11d_1651_05,o.tcga_cm_6171_01a_11d_1651_05,o.tcga_cm_6172_01a_11d_1651_05,o.tcga_d5_5538_01a_01d_1651_05,o.tcga_d5_5539_01a_01d_1651_05,o.tcga_d5_5540_01a_01d_1651_05,o.tcga_d5_5541_01a_01d_1651_05,o.tcga_a6_2675_01a_02d_1721_05,o.tcga_a6_5667_01a_21d_1721_05,o.tcga_aa_3655_01a_02d_1721_05,o.tcga_aa_3660_01a_01d_1721_05,o.tcga_aa_3662_01a_01d_1721_05,o.tcga_aa_3663_01a_01d_1721_05,o.tcga_aa_3697_01a_01d_1721_05,o.tcga_aa_3712_01a_21d_1721_05,o.tcga_aa_3713_01a_21d_1721_05,o.tcga_au_3779_01a_01d_1721_05,o.tcga_au_6004_01a_11d_1721_05,o.tcga_ay_6196_01a_11d_1721_05,o.tcga_ay_6197_01a_11d_1721_05,o.tcga_ay_6386_01a_21d_1721_05,o.tcga_az_5407_01a_01d_1721_05,o.tcga_ck_4950_01a_01d_1721_05,o.tcga_ck_4952_01a_01d_1721_05,o.tcga_cm_4743_01a_01d_1721_05,o.tcga_cm_5344_01a_21d_1721_05,o.tcga_cm_5348_01a_21d_1721_05,o.tcga_cm_5349_01a_21d_1721_05,o.tcga_d5_6530_01a_11d_1721_05,o.tcga_d5_6531_01a_11d_1721_05,o.tcga_d5_6532_01a_11d_1721_05,o.tcga_d5_6533_01a_11d_1721_05,o.tcga_d5_6535_01a_11d_1721_05,o.tcga_d5_6536_01a_11d_1721_05,o.tcga_d5_6537_01a_11d_1721_05,o.tcga_d5_6538_01a_11d_1721_05,o.tcga_d5_6539_01a_11d_1721_05,o.tcga_d5_6540_01a_11d_1721_05,o.tcga_d5_6541_01a_11d_1721_05,o.tcga_f4_6463_01a_11d_1721_05,o.tcga_g4_6293_01a_11d_1721_05,o.tcga_g4_6295_01a_11d_1721_05,o.tcga_g4_6297_01a_11d_1721_05,o.tcga_g4_6298_01a_11d_1721_05,o.tcga_g4_6302_01a_11d_1721_05,o.tcga_g4_6307_01a_11d_1721_05,o.tcga_g4_6310_01a_11d_1721_05,o.tcga_g4_6311_01a_11d_1721_05,o.tcga_g4_6314_01a_11d_1721_05,o.tcga_g4_6315_01a_11d_1721_05,o.tcga_g4_6317_01a_11d_1721_05,o.tcga_g4_6317_02a_11d_2064_05,o.tcga_g4_6320_01a_11d_1721_05,o.tcga_g4_6321_01a_11d_1721_05,o.tcga_g4_6322_01a_11d_1721_05,o.tcga_g4_6323_01a_11d_1721_05,o.tcga_a6_4105_01a_02d_1772_05,o.tcga_a6_6137_01a_11d_1772_05,o.tcga_a6_6138_01a_11d_1772_05,o.tcga_a6_6140_01a_11d_1772_05,o.tcga_a6_6141_01a_11d_1772_05,o.tcga_a6_6142_01a_11d_1772_05,o.tcga_a6_6648_01a_11d_1772_05,o.tcga_a6_6649_01a_11d_1772_05,o.tcga_a6_6650_01a_11d_1772_05,o.tcga_a6_6652_01a_11d_1772_05,o.tcga_a6_6653_01a_11d_1772_05,o.tcga_az_6598_01a_11d_1772_05,o.tcga_az_6599_01a_11d_1772_05,o.tcga_az_6600_01a_11d_1772_05,o.tcga_az_6601_01a_11d_1772_05,o.tcga_d5_6529_01a_11d_1772_05,o.tcga_f4_6459_01a_11d_1772_05,o.tcga_f4_6460_01a_11d_1772_05,o.tcga_f4_6461_01a_11d_1772_05,o.tcga_f4_6569_01a_11d_1772_05,o.tcga_f4_6570_01a_11d_1772_05,o.tcga_g4_6294_01a_11d_1772_05,o.tcga_g4_6299_01a_11d_1772_05,o.tcga_g4_6303_01a_11d_1772_05,o.tcga_g4_6306_01a_11d_1772_05,o.tcga_g4_6586_01a_11d_1772_05,o.tcga_g4_6588_01a_11d_1772_05,o.tcga_g4_6625_01a_21d_1772_05,o.tcga_g4_6626_01a_11d_1772_05,o.tcga_g4_6627_01a_11d_1772_05,o.tcga_dm_a0x9_01a_11d_a153_05,o.tcga_dm_a0xd_01a_12d_a153_05,o.tcga_dm_a0xf_01a_11d_a153_05,o.tcga_dm_a1d0_01a_11d_a153_05,o.tcga_dm_a1d4_01a_21d_a153_05,o.tcga_dm_a1d6_01a_21d_a153_05,o.tcga_dm_a1d7_01a_11d_a153_05,o.tcga_dm_a1d8_01a_11d_a153_05,o.tcga_dm_a1d9_01a_11d_a153_05,o.tcga_dm_a1da_01a_11d_a153_05,o.tcga_dm_a1db_01a_11d_a153_05,o.tcga_dm_a1ha_01a_11d_a153_05,o.tcga_a6_5656_01a_21d_1837_05,o.tcga_a6_5664_01a_21d_1837_05,o.tcga_a6_6651_01a_21d_1837_05,o.tcga_a6_6654_01a_21d_1837_05,o.tcga_a6_6780_01a_11d_1837_05,o.tcga_a6_6782_01a_11d_1837_05,o.tcga_aa_3489_01a_21d_1837_05,o.tcga_aa_3496_01a_21d_1837_05,o.tcga_aa_3511_01a_21d_1837_05,o.tcga_ad_6548_01a_11d_1837_05,o.tcga_az_4323_01a_21d_1837_05,o.tcga_az_4616_01a_21d_1837_05,o.tcga_az_6603_01a_11d_1837_05,o.tcga_az_6605_01a_11d_1837_05,o.tcga_az_6606_01a_11d_1837_05,o.tcga_az_6607_01a_11d_1837_05,o.tcga_az_6608_01a_11d_1837_05,o.tcga_ca_5254_01a_21d_1837_05,o.tcga_ca_5255_01a_11d_1837_05,o.tcga_ca_6715_01a_21d_1837_05,o.tcga_ca_6716_01a_11d_1837_05,o.tcga_ca_6717_01a_11d_1837_05,o.tcga_ca_6718_01a_11d_1837_05,o.tcga_ca_6719_01a_11d_1837_05,o.tcga_ck_6746_01a_11d_1837_05,o.tcga_ck_6747_01a_11d_1837_05,o.tcga_ck_6748_01a_11d_1837_05,o.tcga_ck_6751_01a_11d_1837_05,o.tcga_cm_4751_01a_02d_1837_05,o.tcga_cm_5863_01a_21d_1837_05,o.tcga_cm_6674_01a_11d_1837_05,o.tcga_cm_6675_01a_11d_1837_05,o.tcga_cm_6676_01a_11d_1837_05,o.tcga_cm_6677_01a_11d_1837_05,o.tcga_cm_6678_01a_11d_1837_05,o.tcga_cm_6679_01a_11d_1837_05,o.tcga_cm_6680_01a_11d_1837_05,o.tcga_f4_6703_01a_11d_1837_05,o.tcga_f4_6704_01a_11d_1837_05,o.tcga_f4_6805_01a_11d_1837_05,o.tcga_f4_6806_01a_11d_1837_05,o.tcga_f4_6807_01a_11d_1837_05,o.tcga_f4_6808_01a_11d_1837_05,o.tcga_f4_6809_01a_11d_1837_05,o.tcga_g4_6309_01a_21d_1837_05,o.tcga_g4_6628_01a_11d_1837_05,o.tcga_dm_a280_01a_12d_a16x_05,o.tcga_dm_a282_01a_12d_a16x_05,o.tcga_dm_a285_01a_11d_a16x_05,o.tcga_dm_a288_01a_11d_a16x_05,o.tcga_dm_a28g_01a_11d_a16x_05,o.tcga_dm_a28h_01a_11d_a16x_05,o.tcga_dm_a28m_01a_12d_a16x_05,o.tcga_a6_6781_01a_22d_1926_05,o.tcga_ad_6888_01a_11d_1926_05,o.tcga_ad_6889_01a_11d_1926_05,o.tcga_ad_6890_01a_11d_1926_05,o.tcga_ad_6895_01a_11d_1926_05,o.tcga_ad_6899_01a_11d_1926_05,o.tcga_ad_6901_01a_11d_1926_05,o.tcga_ad_6963_01a_11d_1926_05,o.tcga_ad_6964_01a_11d_1926_05,o.tcga_ad_6965_01a_11d_1926_05,o.tcga_d5_5537_01a_21d_1926_05,o.tcga_d5_6534_01a_21d_1926_05,o.tcga_d5_6898_01a_11d_1926_05,o.tcga_d5_6920_01a_11d_1926_05,o.tcga_d5_6922_01a_11d_1926_05,o.tcga_d5_6924_01a_11d_1926_05,o.tcga_d5_6926_01a_11d_1926_05,o.tcga_d5_6927_01a_21d_1926_05,o.tcga_d5_6928_01a_11d_1926_05,o.tcga_d5_6929_01a_31d_1926_05,o.tcga_d5_6930_01a_11d_1926_05,o.tcga_d5_6931_01a_11d_1926_05,o.tcga_d5_6932_01a_11d_1926_05,o.tcga_f4_6854_01a_11d_1926_05,o.tcga_f4_6855_01a_11d_1926_05,o.tcga_f4_6856_01a_11d_1926_05,o.tcga_f4_6857_01a_11d_1926_05,o.tcga_g4_6304_01a_11d_1926_05,o.tcga_dm_a1hb_01a_22d_a17z_05 FROM coad.humanmethylation450 o, coad.humanmethylation450_probeinfo p WHERE o.probe = p.probe AND p.chromosome = '7' AND p.genomic_coordinate_hg19 > 10000000 ORDER BY p.genomic_coordinate_hg19 LIMIT 100;\")\n                     \n  if (!is.null(and.table)) {\n    y_rs <- dbGetQuery(con, paste('SELECT * FROM', and.table))\n    }\n  system('echo Finished getting data from database $(date)')\n  \n  # Prepare and filter dataframes\n  filter <- function (dataframe, stdev){\n    system('echo Filtering started $(date)')\n    \n    startrow <- nrow(dataframe)\n    df <- na.exclude(dataframe)\n    noNArow <- nrow(df)\n    df$sd <- apply(df[,-1], 1, sd, na.rm=TRUE)\n    df <- subset(df, sd > stdev)\n    df <- df[,-length(df)]\n    endrow <- nrow(df)\n    diffrow <- startrow - endrow\n    noNA <- startrow - noNArow\n    cat(paste('\\n', diffrow, 'probes filtered out.', noNA, 'probes contained NAs\\n'))\n\n    system('echo Filtering ended $(date)')\n\n    return (df)\n  }\n  \n  x_rs <- filter(x_rs, stdev.threshold.from)\n  if (!is.null(and.table)) {\n    y_rs <- filter(y_rs, stdev.threshold.and) \n  }\n\n  # Do all probe correlations\n  \n  correlation <- function (x, y, to.table, pval.threshold){\n    a <- as.numeric(x[-1])\n    b <- as.numeric(y[-1])\n    corr <- cor.test (a, b, method = \"spearman\")\n    count <<- count + 1\n    if (corr$p.value <= pval.threshold) {\n      x_probe_name <- x[1]\n      y_probe_name <- y[1]\n      if (!init){\n        system('echo Initializing connection with PostgreSQL $(date)')\n        con1 <<- connect()\n        dbSendQuery(con1, \"SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\")\n        dbSendQuery(con1, 'BEGIN;')\n        init <<- TRUE\n      }\n\n      # because the pvalue is defined as float(4) in postgres\n      if  (corr$p.value < 5.60519e-45) corr$p.value <- 0\n      \n      statement <- paste(\"INSERT INTO \", to.table, \" VALUES ('\",\n                         x_probe_name, \"', '\", y_probe_name, \"', \",\n                         corr$estimate, \",\", corr$p.value, \");\", sep =  \"\")\n           \n      dbSendQuery(con1, statement)\n    }\n    if (count >= 100000){\n      system('echo 100000 counts done $(date)')\n      dbSendQuery(con1, 'COMMIT;')\n      dbSendQuery(con1, 'BEGIN;')\n      count <<- 0\n    }\n    \n    \n  }\n  \n  apply2 <- function (X, Y, DOMAIN, CTION, ...) {\n    CTION <- match.fun(CTION)\n    dl <- length(dim(Y))\n    if (!dl) \n      stop(\"dim(Y) must have a positive length\")\n    if (is.object(Y)) \n      Y <- if (dl == 2L) \n        as.matrix(Y)\n    else as.array(Y)\n    d <- dim(Y)\n    dn <- dimnames(Y)\n    ds <- seq_len(dl)\n    if (is.character(DOMAIN)) {\n      if (is.null(dnn <- names(dn))) \n        stop(\"'Y' must have named dimnames\")\n      DOMAIN <- match(DOMAIN, dnn)\n      if (any(is.na(DOMAIN))) \n        stop(\"not all elements of 'DOMAIN' are names of dimensions\")\n    }\n    s.call <- ds[-DOMAIN]\n    s.ans <- ds[DOMAIN]\n    d.call <- d[-DOMAIN]\n    d.ans <- d[DOMAIN]\n    dn.call <- dn[-DOMAIN]\n    dn.ans <- dn[DOMAIN]\n    d2 <- prod(d.ans)\n    if (d2 == 0L) {\n      newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call), \n                                                   1L))\n      ans <- CTION(if (length(d.call) < 2L) \n        newY[, 1]\n                   else array(X,newY[, 1L], d.call, dn.call), ...)\n      return(if (is.null(ans)) ans else if (length(d.ans) < \n                                              2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))\n    }\n    newY <- aperm(Y, c(s.call, s.ans))\n    dim(newY) <- c(prod(d.call), d2)\n    ans <- vector(\"list\", d2)\n    if (length(d.call) < 2L) {\n      if (length(dn.call)) \n        dimnames(newY) <- c(dn.call, list(NULL))\n      for (i in 1L:d2) {\n        tmp <- CTION(X,newY[, i], ...)\n        if (!is.null(tmp)) \n          ans[[i]] <- tmp\n      }\n    }\n    else for (i in 1L:d2) {\n      tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)\n      if (!is.null(tmp)) \n        ans[[i]] <- tmp\n    }\n    ans.list <- is.recursive(ans[[1L]])\n    l.ans <- length(ans[[1L]])\n    ans.names <- names(ans[[1L]])\n    if (!ans.list) \n      ans.list <- any(unlist(lapply(ans, length)) != l.ans)\n    if (!ans.list && length(ans.names)) {\n      all.same <- vapply(ans, function(Y) identical(names(Y), \n                                                    ans.names), NA)\n      if (!all(all.same)) \n        ans.names <- NULL\n    }\n    len.a <- if (ans.list) \n      d2\n    else length(ans <- unlist(ans, recursive = FALSE))\n    if (length(DOMAIN) == 1L && len.a == d2) {\n      names(ans) <- if (length(dn.ans[[1L]])) \n        dn.ans[[1L]]\n      return(ans)\n    }\n    if (len.a == d2) \n      return(array(ans, d.ans, dn.ans))\n    if (len.a && len.a%%d2 == 0L) {\n      if (is.null(dn.ans)) \n        dn.ans <- vector(mode = \"list\", length(d.ans))\n      dn.ans <- c(list(ans.names), dn.ans)\n      return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans, \n                                                              is.null, NA))) dn.ans))\n    }\n    return(ans)\n  }\n  \n  apply2half <- function (X, Y, DOMAIN, CTION, ...) {\n    rowmatch <- match(X[1], Y[,1])\n    if (rowmatch < nrow (Y)){\n      Y <- Y[((1L+rowmatch):nrow(Y)),]\n      CTION <- match.fun(CTION)\n      dl <- length(dim(Y))\n      if (!dl) \n        stop(\"dim(Y) must have a positive length\")\n       if (is.object(Y)) \n        Y <- if (dl == 2L) \n          as.matrix(Y)\n      else as.array(Y)\n      d <- dim(Y)\n      dn <- dimnames(Y)\n      ds <- seq_len(dl)\n      if (is.character(DOMAIN)) {\n        if (is.null(dnn <- names(dn))) \n          stop(\"'Y' must have named dimnames\")\n        DOMAIN <- match(DOMAIN, dnn)\n        if (any(is.na(DOMAIN))) \n          stop(\"not all elements of 'DOMAIN' are names of dimensions\")\n      }\n      s.call <- ds[-DOMAIN]\n      s.ans <- ds[DOMAIN]\n      d.call <- d[-DOMAIN]\n      d.ans <- d[DOMAIN]\n      dn.call <- dn[-DOMAIN]\n      dn.ans <- dn[DOMAIN]\n      d2 <- prod(d.ans)\n      if (d2 == 0L) {\n        newY <- array(vector(typeof(Y), 1L), dim = c(prod(d.call), \n                                                     1L))\n        ans <- CTION(if (length(d.call) < 2L) \n          newY[, 1]\n                     else array(X,newY[, 1L], d.call, dn.call), ...)\n        return(if (is.null(ans)) ans else if (length(d.ans) < \n                                                2L) ans[1L][-1L] else array(ans, d.ans, dn.ans))\n      }\n      newY <- aperm(Y, c(s.call, s.ans))\n      dim(newY) <- c(prod(d.call), d2)\n      ans <- vector(\"list\", d2)\n      if (length(d.call) < 2L) {\n        if (length(dn.call)) \n          dimnames(newY) <- c(dn.call, list(NULL))\n        for (i in 1L:d2) {\n          tmp <- CTION(X,newY[, i], ...)\n          if (!is.null(tmp)) \n            ans[[i]] <- tmp\n        }\n      }\n      else for (i in 1L:d2) {\n        tmp <- CTION(array(X,newY[, i], d.call, dn.call), ...)\n        if (!is.null(tmp)) \n          ans[[i]] <- tmp\n      }\n      ans.list <- is.recursive(ans[[1L]])\n      l.ans <- length(ans[[1L]])\n      ans.names <- names(ans[[1L]])\n      if (!ans.list) \n        ans.list <- any(unlist(lapply(ans, length)) != l.ans)\n      if (!ans.list && length(ans.names)) {\n        all.same <- vapply(ans, function(Y) identical(names(Y), \n                                                      ans.names), NA)\n        if (!all(all.same)) \n          ans.names <- NULL\n      }\n      len.a <- if (ans.list) \n        d2\n      else length(ans <- unlist(ans, recursive = FALSE))\n      if (length(DOMAIN) == 1L && len.a == d2) {\n        names(ans) <- if (length(dn.ans[[1L]])) \n          dn.ans[[1L]]\n        return(ans)\n      }\n      if (len.a == d2) \n        return(array(ans, d.ans, dn.ans))\n      if (len.a && len.a%%d2 == 0L) {\n        if (is.null(dn.ans)) \n          dn.ans <- vector(mode = \"list\", length(d.ans))\n        dn.ans <- c(list(ans.names), dn.ans)\n        return(array(ans, c(len.a%/%d2, d.ans), if (!all(vapply(dn.ans, \n                                                                is.null, NA))) dn.ans))\n      }\n      return(ans) \n    }\n  }\n  \n  system('echo Making clusters $(date)')\n  cluster <- makeCluster(NTHREADS)\n  clusterExport(cluster, \"connect\")\n  clusterEvalQ(cluster, library(RPostgreSQL))\n  clusterEvalQ(cluster, init <- FALSE)\n  clusterEvalQ(cluster, count <- 0)\n\n  system('echo Starting parallel apply $(date)')\n  \n  if (!is.null(and.table)) {\n    parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2, Y = y_rs, DOMAIN = 1,\n                  CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)\n    clusterEvalQ(cluster, dbSendQuery(con1, \"COMMIT;\"))\n    stopCluster(cl = cluster)\n  } else {\n    parApply(cl = cluster, X = x_rs, MARGIN = 1, FUN = apply2half, Y = x_rs, DOMAIN = 1,\n                  CTION = correlation, to.table = to.table, pval.threshold = pval.threshold)\n    clusterEvalQ(cluster, dbSendQuery(con1, \"COMMIT;\"))\n    stopCluster(cl = cluster)\n  }\n  return (TRUE)\n}\n\n#\n\n#args <- commandArgs(trailingOnly = TRUE)\n\n#if (length(args) < 2) {\n#  usage()\n#  stop()\n#}\n\n#NTHREADS <- args[1]\n#FROM_TABLE <- args[2]\n#TO_TABLE <- args[3]\n\nNTHREADS <- 8\n\ncon <- connect ()\n\ncorFromTableToTable(con = con,\n                    #from.table = FROM_TABLE,\n                    from.table = 'blablabla',\n                    and.table = NULL,\n                    primary.key = \"probe\",\n                    #to.table = TO_TABLE,\n                    to.table = 'chr7.correlations',\n                    stdev.threshold.from = 0,\n                    stdev.threshold.and = 0,\n                    pval.threshold = 4)\n\n#corFromTableToTable(con = con, from.table = \"coad.humanmethylation450\", and.table = NULL, primary.key = \"probe\", to.table = \"coad.filtered_correlations\", stdev.threshold.from = 0.05, stdev.threshold.and = 0, pval.threshold = 0.05)\ndisconnect(con)\n\ncat('\\nDone ')\nsystem('date')\n",
    "created" : 1394635245254.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1207635563",
    "id" : "ABBF9919",
    "lastKnownWriteTime" : 1387386128,
    "path" : "/imppc/labs/maplab/share/imallona2fchen/DatabaseConnection_3.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}